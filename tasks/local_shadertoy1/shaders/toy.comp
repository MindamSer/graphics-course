#version 430

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rgba8) uniform image2D resultImage;

layout(push_constant) uniform params
{
  float time;
} pushConstant;

#define iTime pushConstant.time


// consts
const float PI = 3.141592;
const vec2 iResolution = vec2(1280., 720.);
const vec2 iMouse = vec2(0.);

// render consts
const int MAX_ITER = 200;
const float MAX_DIST = 1e2;
const float STEP_EPS = 1e-6;
const float H = 1e-2;
const float BLICK_POW = 5e1;
const float SHADOW_K = 16.;
const float CORE_SMOOTH = 0.05;

// scene consts
float NUCLEON_SIZE = 0.3;
float NUCLEON_OFFSET = 0.4;
float CORE_OMEGA = 1.;
float ELECTRON_SIZE = 0.1;
float ELECTRON_OFFSET = 2.;
float ELECTRON_OMEGA = 0.5;



// render structures
struct camera {
    vec3 pos;
    vec3 dir;
    vec3 up;
    float fov;
};

struct light {
    vec3 pos;
    vec4 col;
};



// rotation matrices
mat3 rotateAxis(vec3 axis, float theta) {
    float c = cos(theta);
    float s = sin(theta);
    float x = axis.x;
    float y = axis.y;
    float z = axis.z;
    return mat3(
        vec3(c + (1. - c) * x * x, (1. - c) * x * y - s * z, (1. - c) * x * z + s * y),
        vec3((1. - c) * y * x + s * z, c + (1. - c) * y * y, (1. - c) * y * z - s * x),
        vec3((1. - c) * z * x - s * y, (1. - c) * z * y + s * x, c + (1. - c) * z * z)
    );
}

mat3 rotateX(float theta) {
    return rotateAxis(vec3(1., 0., 0.), theta);
}

mat3 rotateY(float theta) {
    return rotateAxis(vec3(0., 1., 0.), theta);
}

mat3 rotateZ(float theta) {
    return rotateAxis(vec3(0., 0., 1.), theta);
}



// sdf functions
float sdSphere(vec3 p, float s)
{
      return length(p) - s;
}

float opSmoothUnion( float d1, float d2, float k )
{
    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );
    return mix( d2, d1, h ) - k*h*(1.0-h);
}

float sdCore(vec3 p, vec3 cent)
{
    p = rotateAxis(normalize(vec3(1., 1., 1.)), PI * CORE_OMEGA * iTime) * p;
    int nucleonCount = 12;
    
    vec3[] nucleons = vec3[] (
    NUCLEON_OFFSET * normalize(vec3(3., 1., 1.)), NUCLEON_OFFSET * normalize(vec3(3., -1., -1.)),
    NUCLEON_OFFSET * normalize(vec3(1., 3., 1.)), NUCLEON_OFFSET * normalize(vec3(-1., 3., -1.)),
    NUCLEON_OFFSET * normalize(vec3(-1., 1., 3.)), NUCLEON_OFFSET * normalize(vec3(1., -1., 3.)),
    NUCLEON_OFFSET * normalize(vec3(-3., 1., -1.)), NUCLEON_OFFSET * normalize(vec3(-3., -1., 1.)),
    NUCLEON_OFFSET * normalize(vec3(-1., -3., -1.)), NUCLEON_OFFSET * normalize(vec3(1., -3., 1.)),
    NUCLEON_OFFSET * normalize(vec3(1., 1., -3.)), NUCLEON_OFFSET * normalize(vec3(-1., -1., -3.))
    );
    
    float res = sdSphere(p - (cent + nucleons[0]), NUCLEON_SIZE);
    for (int i = 0; i < nucleonCount; i++)
    {
        res = opSmoothUnion(res, sdSphere(p - (cent + nucleons[i]), NUCLEON_SIZE), CORE_SMOOTH);
    }
    return res;
}

float sdOrbiltals(vec3 p, vec3 cent)
{
    int electronCount = 6;
    vec3[] electrons = vec3[] (
    rotateAxis(normalize(vec3(-3., 2., 0.)), PI * ELECTRON_OMEGA * iTime * 1.05) * ELECTRON_OFFSET * normalize(vec3(2., 3., 0.)),
    rotateAxis(normalize(vec3(3., 2., 0.)), PI * ELECTRON_OMEGA * iTime * 1.07) * ELECTRON_OFFSET * normalize(vec3(-2., 3., 0.)),
    rotateAxis(normalize(vec3(0., -3., 2.)), PI * ELECTRON_OMEGA * iTime * 1.11) * ELECTRON_OFFSET * normalize(vec3(0., 2., 3.)),
    rotateAxis(normalize(vec3(0., 3., 2.)), PI * ELECTRON_OMEGA * iTime * 1.13) * ELECTRON_OFFSET * normalize(vec3(0., -2., 3.)),
    rotateAxis(normalize(vec3(-3., 0., 2.)), PI * ELECTRON_OMEGA * iTime * 1.17) * ELECTRON_OFFSET * normalize(vec3(2., 0., 3.)),
    rotateAxis(normalize(vec3(3., 0., 2.)), PI * ELECTRON_OMEGA * iTime * 1.19) * ELECTRON_OFFSET * normalize(vec3(-2., 0., 3.))
    );
    
    float res = sdSphere(p - (cent + electrons[0]), ELECTRON_SIZE);
    for (int i = 0; i < electronCount; i++)
    {
        res = min(res, sdSphere(p - (cent + electrons[i]), ELECTRON_SIZE));
    }
    return res;
}



// scene sdf function
float sceneSDF(vec3 p )
{ 
    return min(sdCore(p, vec3(0.)), sdOrbiltals(p, vec3(0.)));
}



vec3 getNormal(vec3 p)
{
    float dx1 = sceneSDF(p + vec3(H, 0, 0));
    float dx2 = sceneSDF(p - vec3(H, 0, 0));
    float dy1 = sceneSDF(p + vec3(0, H, 0));
    float dy2 = sceneSDF(p - vec3(0, H, 0));
    float dz1 = sceneSDF(p + vec3(0, 0, H));
    float dz2 = sceneSDF(p - vec3(0, 0, H));
    
    return normalize(vec3(dx1 - dx2, dy1 - dy2, dz1 - dz2));
}



vec3 trace(in vec3 start, in vec3 dir, out bool hit)
{
    vec3 p = vec3(0.);
    float t = 0.;
    float d = 0.;
    
    for (int i = 0; i < MAX_ITER; ++i)
    {
        p = start + dir * t;
        d = sceneSDF(p);
        t += d;
        
        if (d < STEP_EPS || t > MAX_DIST) break;
    }
    
    if (d < STEP_EPS) hit = true;
    
    return p;
}



float softshadow(in vec3 ro, in vec3 rd, float k)
{
    float res = 1.0;
    float t = STEP_EPS * 10.;
    for( int i=0; i<MAX_ITER && t<MAX_DIST; i++ )
    {
        float h = sceneSDF(ro + rd*t);
        if( h < STEP_EPS )
            return 0.0;
        res = min( res, k*h/t );
        t += h;
    }
    return res;
}



camera mainCam = camera(vec3(0., 0., 5.), vec3(0., 0., -1.), vec3(0., 1., 0.), 100.);

int lightCount = 6;
light[] ligths = light[] (
light(vec3(0., 4., 3.), vec4(1., 0., 0., 1.)),
light(vec3(-2., -3., 3.), vec4(0., 1., 0., 1.)),
light(vec3(2., -3., 3.), vec4(0., 0., 1., 1.)),
light(vec3(-2., 3., -3.), vec4(1., 1., 0., 1.)),
light(vec3(2., 3., -3.), vec4(1., 0., 1., 1.)),
light(vec3(0., -4., -3.), vec4(0., 1., 1., 1.))
);

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // angle of camera
    vec2 mouseTheta = PI * (iMouse.xy * 2. - iResolution.xy) / iResolution.x;
    float phi = mouseTheta.x;
    float theta = mouseTheta.y;
    
    // moving camera
    vec3 frameCameraPos = rotateY(phi) * mainCam.pos;
    vec3 frameCameraDir = rotateY(phi) * mainCam.dir;
    vec3 frameCameraUp = mainCam.up;
    vec3 frameCameraRight = cross(frameCameraDir, frameCameraUp);
    frameCameraPos = rotateAxis(frameCameraRight, -theta) * frameCameraPos;
    frameCameraDir = rotateAxis(frameCameraRight, -theta) * frameCameraDir;
    frameCameraUp = rotateAxis(frameCameraRight, -theta) * frameCameraUp;
    float cameraDepth = 1. / tan(radians(mainCam.fov / 2.));
    
    // computing ray direction
    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.x;
    vec3 rayDir = normalize(frameCameraDir * cameraDepth + frameCameraRight * uv.x + frameCameraUp * uv.y);
    
    //tracing ray
    bool hit = false;
    vec3 p = trace(frameCameraPos, rayDir, hit);
    
    vec4 color = vec4(vec3(0.), 1.);
    
    // process hit case
    if (hit)
    {
        vec3 n = getNormal(p);
        vec3 hc = normalize(frameCameraPos - p);
        for (int i = 0; i < lightCount; i++)
        {
            vec3 hl = normalize(ligths[i].pos - p);
            float brightness = softshadow(p, hl, SHADOW_K) * max(0., dot(n, hl));
            float blick = pow(brightness, BLICK_POW);
            color = color + (0.05 + 0.475 * brightness + 0.475 * blick) * ligths[i].col;
        }
    }

    fragColor = color;
}


void main()
{
  // angle of camera
  vec2 mouseTheta = PI * (iMouse.xy * 2. - iResolution.xy) / iResolution.x;
  float phi = mouseTheta.x;
  float theta = mouseTheta.y;
  
  // moving camera
  vec3 frameCameraPos = rotateY(phi) * mainCam.pos;
  vec3 frameCameraDir = rotateY(phi) * mainCam.dir;
  vec3 frameCameraUp = mainCam.up;
  vec3 frameCameraRight = cross(frameCameraDir, frameCameraUp);
  frameCameraPos = rotateAxis(frameCameraRight, -theta) * frameCameraPos;
  frameCameraDir = rotateAxis(frameCameraRight, -theta) * frameCameraDir;
  frameCameraUp = rotateAxis(frameCameraRight, -theta) * frameCameraUp;
  float cameraDepth = 1. / tan(radians(mainCam.fov / 2.));

  
  ivec2 fragCoord = ivec2(gl_GlobalInvocationID.xy);
  vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.x;
  vec3 rayDir = normalize(frameCameraDir * cameraDepth + frameCameraRight * uv.x + frameCameraUp * uv.y);
    
  //tracing ray
  bool hit = false;
  vec3 p = trace(frameCameraPos, rayDir, hit);
  
  vec4 color = vec4(vec3(0.), 1.);
  
  // process hit case
  if (hit)
  {
      vec3 n = getNormal(p);
      vec3 hc = normalize(frameCameraPos - p);
      for (int i = 0; i < lightCount; i++)
      {
          vec3 hl = normalize(ligths[i].pos - p);
          float brightness = softshadow(p, hl, SHADOW_K) * max(0., dot(n, hl));
          float blick = pow(brightness, BLICK_POW);
          color = color + (0.05 + 0.475 * brightness + 0.475 * blick) * ligths[i].col;
      }
  }
  
  

  if (fragCoord.x < 1280 && fragCoord.y < 720)
    imageStore(resultImage, fragCoord, color);
}
